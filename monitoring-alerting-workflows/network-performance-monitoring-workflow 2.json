{
  "name": "Network Performance Monitoring",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 1
            }
          ]
        }
      },
      "id": "e1d1c5a8-8b4e-4b5a-9c8d-1e2f3a4b5c6d",
      "name": "Every 1 Minute",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1,
      "position": [
        240,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Network Performance Monitoring Configuration\n// Comprehensive monitoring of network performance metrics\n\nconst performanceConfig = {\n  // Performance metrics to monitor\n  metrics: {\n    latency: {\n      description: 'End-to-end network latency',\n      unit: 'milliseconds',\n      thresholds: {\n        excellent: 20,\n        good: 50,\n        acceptable: 100,\n        poor: 200,\n        critical: 500\n      }\n    },\n    throughput: {\n      description: 'Network bandwidth utilization',\n      unit: 'percentage',\n      thresholds: {\n        excellent: 30,\n        good: 50,\n        acceptable: 70,\n        poor: 85,\n        critical: 95\n      }\n    },\n    packet_loss: {\n      description: 'Packet loss percentage',\n      unit: 'percentage',\n      thresholds: {\n        excellent: 0.01,\n        good: 0.1,\n        acceptable: 0.5,\n        poor: 1.0,\n        critical: 5.0\n      }\n    },\n    jitter: {\n      description: 'Network jitter variance',\n      unit: 'milliseconds',\n      thresholds: {\n        excellent: 5,\n        good: 15,\n        acceptable: 30,\n        poor: 50,\n        critical: 100\n      }\n    },\n    availability: {\n      description: 'Network service availability',\n      unit: 'percentage',\n      thresholds: {\n        excellent: 99.9,\n        good: 99.5,\n        acceptable: 99.0,\n        poor: 98.0,\n        critical: 95.0\n      }\n    },\n    response_time: {\n      description: 'Application response time',\n      unit: 'milliseconds',\n      thresholds: {\n        excellent: 100,\n        good: 250,\n        acceptable: 500,\n        poor: 1000,\n        critical: 2000\n      }\n    }\n  },\n  \n  // Network segments to monitor\n  segments: {\n    'wan_links': {\n      description: 'WAN connection performance',\n      priority: 'critical',\n      tests: ['latency', 'throughput', 'packet_loss', 'jitter', 'availability']\n    },\n    'lan_backbone': {\n      description: 'LAN backbone performance',\n      priority: 'high',\n      tests: ['latency', 'throughput', 'packet_loss']\n    },\n    'wireless_networks': {\n      description: 'Wireless network performance',\n      priority: 'high',\n      tests: ['latency', 'throughput', 'packet_loss', 'response_time']\n    },\n    'internet_connectivity': {\n      description: 'Internet access performance',\n      priority: 'high',\n      tests: ['latency', 'throughput', 'packet_loss', 'availability']\n    },\n    'application_performance': {\n      description: 'Application-specific performance',\n      priority: 'medium',\n      tests: ['response_time', 'availability', 'throughput']\n    }\n  },\n  \n  // Test locations and targets\n  test_targets: {\n    'primary_dc': {\n      name: 'Primary Data Center',\n      ip: '10.0.1.1',\n      location: 'headquarters',\n      tests: ['ping', 'traceroute', 'bandwidth']\n    },\n    'secondary_dc': {\n      name: 'Secondary Data Center',\n      ip: '10.0.2.1',\n      location: 'dr_site',\n      tests: ['ping', 'traceroute', 'bandwidth']\n    },\n    'internet_gateway': {\n      name: 'Internet Gateway',\n      ip: '8.8.8.8',\n      location: 'external',\n      tests: ['ping', 'traceroute']\n    },\n    'cloud_services': {\n      name: 'Cloud Services',\n      targets: ['office365.com', 'salesforce.com', 'aws.amazon.com'],\n      location: 'cloud',\n      tests: ['ping', 'http_response']\n    }\n  },\n  \n  // Performance baselines\n  baselines: {\n    'business_hours': {\n      description: 'Performance during business hours (8AM-6PM)',\n      timeframe: '8-18',\n      expected_degradation: 0.2\n    },\n    'off_hours': {\n      description: 'Performance during off hours',\n      timeframe: '18-8',\n      expected_degradation: 0.1\n    },\n    'weekend': {\n      description: 'Weekend performance baseline',\n      timeframe: 'weekend',\n      expected_degradation: 0.05\n    }\n  },\n  \n  // Alert configuration\n  alerting: {\n    immediate_alerts: ['critical'],\n    batch_alerts: ['poor', 'acceptable'],\n    trend_alerts: true,\n    anomaly_detection: true,\n    alert_suppression: 300, // 5 minutes\n    escalation_time: 900    // 15 minutes\n  },\n  \n  timestamp: new Date().toISOString()\n};\n\n// Generate performance test matrix\nconst performanceTests = [];\n\nObject.keys(performanceConfig.segments).forEach(segmentKey => {\n  const segment = performanceConfig.segments[segmentKey];\n  \n  segment.tests.forEach(testType => {\n    const metric = performanceConfig.metrics[testType];\n    \n    Object.keys(performanceConfig.test_targets).forEach(targetKey => {\n      const target = performanceConfig.test_targets[targetKey];\n      \n      performanceTests.push({\n        test_id: `${segmentKey}_${testType}_${targetKey}`,\n        segment: segmentKey,\n        metric: testType,\n        target: targetKey,\n        target_config: target,\n        thresholds: metric.thresholds,\n        priority: segment.priority,\n        description: `${testType} test for ${segment.description} to ${target.name}`\n      });\n    });\n  });\n});\n\n// UXI integration for user experience metrics\nconst uxiConfig = {\n  enabled: true,\n  sensors: {\n    'office_sensor_1': {\n      location: 'main_office',\n      floor: '1',\n      department: 'sales'\n    },\n    'office_sensor_2': {\n      location: 'main_office',\n      floor: '2',\n      department: 'engineering'\n    },\n    'branch_sensor_1': {\n      location: 'branch_office',\n      floor: '1',\n      department: 'operations'\n    }\n  },\n  test_types: {\n    'web_browsing': {\n      url: 'https://www.google.com',\n      expected_response_time: 200,\n      frequency: '1m'\n    },\n    'email_access': {\n      server: 'exchange.company.com',\n      expected_response_time: 100,\n      frequency: '5m'\n    },\n    'file_share': {\n      server: 'fileserver.company.com',\n      expected_response_time: 50,\n      frequency: '5m'\n    },\n    'video_streaming': {\n      url: 'https://teams.microsoft.com',\n      expected_quality: 'hd',\n      frequency: '10m'\n    }\n  }\n};\n\nreturn [{\n  json: {\n    performance_config: performanceConfig,\n    performance_tests: performanceTests,\n    uxi_config: uxiConfig,\n    total_tests: performanceTests.length,\n    execution_time: new Date().toISOString()\n  }\n}];"
      },
      "id": "f2e3d6c9-9c5f-5c6a-ad9e-2f3a4b5c6d7e",
      "name": "Initialize Performance Monitoring",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        460,
        300
      ]
    },
    {
      "parameters": {
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "uxiApi",
        "url": "https://api.uxi.aruba.com/api/v1/sensors",
        "method": "GET",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer {{$credentials.bearerToken}}"
            },
            {
              "name": "Accept",
              "value": "application/json"
            }
          ]
        },
        "options": {
          "timeout": 30000,
          "retry": {
            "maxTries": 3,
            "waitBetweenTries": 2000
          }
        }
      },
      "id": "a3b4c5d6-ad5f-6d7a-be8f-3a4b5c6d7e8f",
      "name": "Get UXI Sensors",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        680,
        200
      ]
    },
    {
      "parameters": {
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "uxiApi",
        "url": "https://api.uxi.aruba.com/api/v1/tests/results",
        "method": "GET",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer {{$credentials.bearerToken}}"
            },
            {
              "name": "Accept",
              "value": "application/json"
            }
          ]
        },
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "from",
              "value": "={{Math.floor((Date.now() - 300000) / 1000)}}"
            },
            {
              "name": "to",
              "value": "={{Math.floor(Date.now() / 1000)}}"
            },
            {
              "name": "limit",
              "value": "1000"
            }
          ]
        },
        "options": {
          "timeout": 30000,
          "retry": {
            "maxTries": 3,
            "waitBetweenTries": 2000
          }
        }
      },
      "id": "b4c5d6e7-be8f-7e8f-cf9a-4b5c6d7e8f9a",
      "name": "Get UXI Test Results",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        680,
        300
      ]
    },
    {
      "parameters": {
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "arubaNetworkingCentralApi",
        "url": "https://apigw-uswest4.central.arubanetworks.com/api/v2/monitoring/networks",
        "method": "GET",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer {{$credentials.accessToken}}"
            },
            {
              "name": "Accept",
              "value": "application/json"
            }
          ]
        },
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "timeframe",
              "value": "5m"
            },
            {
              "name": "metrics",
              "value": "throughput,latency,packet_loss,utilization"
            },
            {
              "name": "limit",
              "value": "100"
            }
          ]
        },
        "options": {
          "timeout": 30000,
          "retry": {
            "maxTries": 3,
            "waitBetweenTries": 2000
          }
        }
      },
      "id": "c5d6e7f8-cf9a-8f9a-da0b-5c6d7e8f9a0b",
      "name": "Get Network Metrics",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        680,
        400
      ]
    },
    {
      "parameters": {
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "edgeConnectApi",
        "url": "https://orchestrator.example.com/api/v1/appliances/metrics",
        "method": "GET",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer {{$credentials.apiKey}}"
            },
            {
              "name": "Accept",
              "value": "application/json"
            }
          ]
        },
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "timeframe",
              "value": "5m"
            },
            {
              "name": "metrics",
              "value": "wan_latency,wan_throughput,wan_packet_loss,wan_jitter"
            },
            {
              "name": "aggregation",
              "value": "average"
            }
          ]
        },
        "options": {
          "timeout": 30000,
          "retry": {
            "maxTries": 3,
            "waitBetweenTries": 2000
          }
        }
      },
      "id": "d6e7f8a9-da0b-9a0b-eb1c-6d7e8f9a0b1c",
      "name": "Get WAN Performance",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        680,
        500
      ]
    },
    {
      "parameters": {
        "jsCode": "// Analyze and correlate network performance data\nconst uxiSensors = $input.first()?.json?.sensors || [];\nconst uxiResults = $input.all()[1]?.json?.results || [];\nconst networkMetrics = $input.all()[2]?.json?.metrics || [];\nconst wanMetrics = $input.all()[3]?.json?.wan_metrics || [];\n\nconst performanceConfig = $input.first().json.performance_config;\nconst thresholds = performanceConfig.metrics;\n\n// Function to calculate performance score\nfunction calculatePerformanceScore(value, metric) {\n  const t = thresholds[metric]?.thresholds;\n  if (!t) return 100;\n  \n  if (value <= t.excellent) return 100;\n  if (value <= t.good) return 85;\n  if (value <= t.acceptable) return 70;\n  if (value <= t.poor) return 50;\n  if (value <= t.critical) return 25;\n  return 0;\n}\n\n// Function to determine status level\nfunction getStatusLevel(value, metric) {\n  const t = thresholds[metric]?.thresholds;\n  if (!t) return 'unknown';\n  \n  if (value <= t.excellent) return 'excellent';\n  if (value <= t.good) return 'good';\n  if (value <= t.acceptable) return 'acceptable';\n  if (value <= t.poor) return 'poor';\n  return 'critical';\n}\n\n// Process UXI sensor data\nconst uxiPerformance = uxiSensors.map(sensor => {\n  const sensorResults = uxiResults.filter(r => r.sensor_id === sensor.id);\n  \n  const latencyResults = sensorResults.filter(r => r.test_type === 'latency');\n  const throughputResults = sensorResults.filter(r => r.test_type === 'throughput');\n  const responseTimeResults = sensorResults.filter(r => r.test_type === 'response_time');\n  \n  const avgLatency = latencyResults.reduce((sum, r) => sum + r.value, 0) / latencyResults.length || 0;\n  const avgThroughput = throughputResults.reduce((sum, r) => sum + r.value, 0) / throughputResults.length || 0;\n  const avgResponseTime = responseTimeResults.reduce((sum, r) => sum + r.value, 0) / responseTimeResults.length || 0;\n  \n  const latencyScore = calculatePerformanceScore(avgLatency, 'latency');\n  const throughputScore = calculatePerformanceScore(avgThroughput, 'throughput');\n  const responseTimeScore = calculatePerformanceScore(avgResponseTime, 'response_time');\n  \n  const overallScore = (latencyScore + throughputScore + responseTimeScore) / 3;\n  \n  return {\n    sensor_id: sensor.id,\n    sensor_name: sensor.name,\n    location: sensor.location,\n    metrics: {\n      latency: {\n        value: avgLatency,\n        score: latencyScore,\n        status: getStatusLevel(avgLatency, 'latency'),\n        unit: 'ms'\n      },\n      throughput: {\n        value: avgThroughput,\n        score: throughputScore,\n        status: getStatusLevel(avgThroughput, 'throughput'),\n        unit: 'Mbps'\n      },\n      response_time: {\n        value: avgResponseTime,\n        score: responseTimeScore,\n        status: getStatusLevel(avgResponseTime, 'response_time'),\n        unit: 'ms'\n      }\n    },\n    overall_score: overallScore,\n    overall_status: getStatusLevel(overallScore, 'latency'), // Use latency thresholds for overall score\n    test_count: sensorResults.length,\n    last_updated: new Date().toISOString()\n  };\n});\n\n// Process network infrastructure metrics\nconst networkPerformance = networkMetrics.map(metric => {\n  const latencyScore = calculatePerformanceScore(metric.latency, 'latency');\n  const throughputScore = calculatePerformanceScore(metric.utilization, 'throughput');\n  const packetLossScore = calculatePerformanceScore(metric.packet_loss, 'packet_loss');\n  \n  const overallScore = (latencyScore + throughputScore + packetLossScore) / 3;\n  \n  return {\n    network_id: metric.network_id,\n    network_name: metric.network_name,\n    network_type: metric.network_type,\n    metrics: {\n      latency: {\n        value: metric.latency,\n        score: latencyScore,\n        status: getStatusLevel(metric.latency, 'latency'),\n        unit: 'ms'\n      },\n      throughput: {\n        value: metric.utilization,\n        score: throughputScore,\n        status: getStatusLevel(metric.utilization, 'throughput'),\n        unit: '%'\n      },\n      packet_loss: {\n        value: metric.packet_loss,\n        score: packetLossScore,\n        status: getStatusLevel(metric.packet_loss, 'packet_loss'),\n        unit: '%'\n      }\n    },\n    overall_score: overallScore,\n    overall_status: overallScore >= 85 ? 'excellent' : overallScore >= 70 ? 'good' : overallScore >= 50 ? 'acceptable' : overallScore >= 25 ? 'poor' : 'critical',\n    last_updated: new Date().toISOString()\n  };\n});\n\n// Process WAN performance metrics\nconst wanPerformance = wanMetrics.map(wan => {\n  const latencyScore = calculatePerformanceScore(wan.latency, 'latency');\n  const throughputScore = calculatePerformanceScore(wan.utilization, 'throughput');\n  const packetLossScore = calculatePerformanceScore(wan.packet_loss, 'packet_loss');\n  const jitterScore = calculatePerformanceScore(wan.jitter, 'jitter');\n  \n  const overallScore = (latencyScore + throughputScore + packetLossScore + jitterScore) / 4;\n  \n  return {\n    wan_id: wan.appliance_id,\n    wan_name: wan.appliance_name,\n    wan_type: wan.wan_type,\n    metrics: {\n      latency: {\n        value: wan.latency,\n        score: latencyScore,\n        status: getStatusLevel(wan.latency, 'latency'),\n        unit: 'ms'\n      },\n      throughput: {\n        value: wan.utilization,\n        score: throughputScore,\n        status: getStatusLevel(wan.utilization, 'throughput'),\n        unit: '%'\n      },\n      packet_loss: {\n        value: wan.packet_loss,\n        score: packetLossScore,\n        status: getStatusLevel(wan.packet_loss, 'packet_loss'),\n        unit: '%'\n      },\n      jitter: {\n        value: wan.jitter,\n        score: jitterScore,\n        status: getStatusLevel(wan.jitter, 'jitter'),\n        unit: 'ms'\n      }\n    },\n    overall_score: overallScore,\n    overall_status: overallScore >= 85 ? 'excellent' : overallScore >= 70 ? 'good' : overallScore >= 50 ? 'acceptable' : overallScore >= 25 ? 'poor' : 'critical',\n    last_updated: new Date().toISOString()\n  };\n});\n\n// Calculate overall network performance summary\nconst allPerformanceData = [...uxiPerformance, ...networkPerformance, ...wanPerformance];\nconst overallNetworkScore = allPerformanceData.reduce((sum, item) => sum + item.overall_score, 0) / allPerformanceData.length || 0;\n\nconst summary = {\n  total_monitored_points: allPerformanceData.length,\n  uxi_sensors: uxiPerformance.length,\n  network_segments: networkPerformance.length,\n  wan_connections: wanPerformance.length,\n  overall_network_score: overallNetworkScore,\n  overall_network_status: overallNetworkScore >= 85 ? 'excellent' : overallNetworkScore >= 70 ? 'good' : overallNetworkScore >= 50 ? 'acceptable' : overallNetworkScore >= 25 ? 'poor' : 'critical',\n  performance_distribution: {\n    excellent: allPerformanceData.filter(d => d.overall_status === 'excellent').length,\n    good: allPerformanceData.filter(d => d.overall_status === 'good').length,\n    acceptable: allPerformanceData.filter(d => d.overall_status === 'acceptable').length,\n    poor: allPerformanceData.filter(d => d.overall_status === 'poor').length,\n    critical: allPerformanceData.filter(d => d.overall_status === 'critical').length\n  }\n};\n\n// Identify performance issues\nconst criticalPerformance = allPerformanceData.filter(d => d.overall_status === 'critical');\nconst poorPerformance = allPerformanceData.filter(d => d.overall_status === 'poor');\n\n// Generate performance insights\nconst insights = [];\n\n// Check for widespread latency issues\nconst highLatencyCount = allPerformanceData.filter(d => \n  d.metrics.latency && d.metrics.latency.status === 'critical'\n).length;\n\nif (highLatencyCount > allPerformanceData.length * 0.3) {\n  insights.push({\n    type: 'widespread_latency',\n    severity: 'high',\n    description: `High latency detected across ${highLatencyCount} network points (${Math.round(highLatencyCount / allPerformanceData.length * 100)}%)`,\n    recommendation: 'Investigate network congestion and routing issues'\n  });\n}\n\n// Check for throughput bottlenecks\nconst lowThroughputCount = allPerformanceData.filter(d => \n  d.metrics.throughput && d.metrics.throughput.status === 'critical'\n).length;\n\nif (lowThroughputCount > 0) {\n  insights.push({\n    type: 'throughput_bottleneck',\n    severity: 'medium',\n    description: `Throughput bottlenecks detected at ${lowThroughputCount} network points`,\n    recommendation: 'Review bandwidth allocation and QoS policies'\n  });\n}\n\n// Check for packet loss patterns\nconst packetLossCount = allPerformanceData.filter(d => \n  d.metrics.packet_loss && d.metrics.packet_loss.status === 'critical'\n).length;\n\nif (packetLossCount > 0) {\n  insights.push({\n    type: 'packet_loss',\n    severity: 'high',\n    description: `Packet loss detected at ${packetLossCount} network points`,\n    recommendation: 'Investigate network stability and hardware health'\n  });\n}\n\n// Performance trends (simplified - would need historical data)\nconst trends = {\n  latency_trend: 'stable', // Would calculate from historical data\n  throughput_trend: 'stable',\n  packet_loss_trend: 'stable',\n  overall_trend: 'stable'\n};\n\nreturn [{\n  json: {\n    timestamp: new Date().toISOString(),\n    summary: summary,\n    uxi_performance: uxiPerformance,\n    network_performance: networkPerformance,\n    wan_performance: wanPerformance,\n    critical_performance: criticalPerformance,\n    poor_performance: poorPerformance,\n    insights: insights,\n    trends: trends,\n    monitoring_interval: '1m',\n    next_check: new Date(Date.now() + 60000).toISOString()\n  }\n}];"
      },
      "id": "e7f8a9b0-eb1c-a0b1-fc2d-7e8f9a0b1c2d",
      "name": "Analyze Performance Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        900,
        300
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition1",
              "leftValue": "={{$json.summary.overall_network_status}}",
              "rightValue": "critical",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "or",
          "conditions2": [
            {
              "id": "condition2",
              "leftValue": "={{$json.critical_performance.length}}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ]
        },
        "options": {}
      },
      "id": "f8a9b0c1-fc2d-b1c2-ad3e-8f9a0b1c2d3e",
      "name": "Check Critical Performance",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1120,
        200
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition1",
              "leftValue": "={{$json.summary.overall_network_status}}",
              "rightValue": "poor",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "or",
          "conditions2": [
            {
              "id": "condition2",
              "leftValue": "={{$json.poor_performance.length}}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ]
        },
        "options": {}
      },
      "id": "a9b0c1d2-ad3e-c2d3-be4f-9a0b1c2d3e4f",
      "name": "Check Poor Performance",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1120,
        400
      ]
    },
    {
      "parameters": {
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "slackApi",
        "select": "channel",
        "channelId": {
          "__rl": true,
          "value": "C06TQSQMKQM",
          "mode": "id"
        },
        "text": "ðŸš¨ **CRITICAL NETWORK PERFORMANCE ALERT** ðŸš¨\\n\\n**Overall Network Score:** {{Math.round($json.summary.overall_network_score)}}% ({{$json.summary.overall_network_status.toUpperCase()}})\\n\\n**Critical Performance Issues:**\\n{{$json.critical_performance.map(p => `â€¢ ${p.sensor_name || p.network_name || p.wan_name}: ${Math.round(p.overall_score)}% - ${p.overall_status}`).join('\\n')}}\\n\\n**Network Insights:**\\n{{$json.insights.filter(i => i.severity === 'high').map(i => `â€¢ ${i.description}`).join('\\n')}}\\n\\n**Immediate Actions:**\\n{{$json.insights.filter(i => i.severity === 'high').map(i => `â€¢ ${i.recommendation}`).join('\\n')}}\\n\\n**Performance Distribution:**\\nâ€¢ Excellent: {{$json.summary.performance_distribution.excellent}}\\nâ€¢ Good: {{$json.summary.performance_distribution.good}}\\nâ€¢ Acceptable: {{$json.summary.performance_distribution.acceptable}}\\nâ€¢ Poor: {{$json.summary.performance_distribution.poor}}\\nâ€¢ Critical: {{$json.summary.performance_distribution.critical}}\\n\\n**Timestamp:** {{$json.timestamp}}",
        "otherOptions": {
          "mrkdwn": true,
          "unfurl_links": false,
          "unfurl_media": false
        }
      },
      "id": "b0c1d2e3-be4f-d3e4-cf5a-0b1c2d3e4f5a",
      "name": "Critical Performance Alert",
      "type": "n8n-nodes-base.slack",
      "typeVersion": 2,
      "position": [
        1340,
        100
      ]
    },
    {
      "parameters": {
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "slackApi",
        "select": "channel",
        "channelId": {
          "__rl": true,
          "value": "C06TQSQMKQM",
          "mode": "id"
        },
        "text": "âš ï¸ **Network Performance Warning** âš ï¸\\n\\n**Overall Network Score:** {{Math.round($json.summary.overall_network_score)}}% ({{$json.summary.overall_network_status.toUpperCase()}})\\n\\n**Poor Performance Areas:**\\n{{$json.poor_performance.slice(0, 5).map(p => `â€¢ ${p.sensor_name || p.network_name || p.wan_name}: ${Math.round(p.overall_score)}% - Primary issues: ${Object.keys(p.metrics).filter(k => p.metrics[k].status === 'poor' || p.metrics[k].status === 'critical').join(', ')}`).join('\\n')}}\\n{{$json.poor_performance.length > 5 ? `\\n... and ${$json.poor_performance.length - 5} more performance issues` : ''}}\\n\\n**Recommended Actions:**\\n{{$json.insights.filter(i => i.severity === 'medium').map(i => `â€¢ ${i.recommendation}`).join('\\n')}}\\n\\n**Performance Metrics:**\\nâ€¢ UXI Sensors: {{$json.summary.uxi_sensors}} monitored\\nâ€¢ Network Segments: {{$json.summary.network_segments}} monitored\\nâ€¢ WAN Connections: {{$json.summary.wan_connections}} monitored\\n\\n**Timestamp:** {{$json.timestamp}}",
        "otherOptions": {
          "mrkdwn": true,
          "unfurl_links": false,
          "unfurl_media": false
        }
      },
      "id": "c1d2e3f4-cf5a-e4f5-da6b-1c2d3e4f5a6b",
      "name": "Poor Performance Alert",
      "type": "n8n-nodes-base.slack",
      "typeVersion": 2,
      "position": [
        1340,
        300
      ]
    },
    {
      "parameters": {
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "slackApi",
        "select": "channel",
        "channelId": {
          "__rl": true,
          "value": "C06TQSQMKQM",
          "mode": "id"
        },
        "text": "âœ… **Network Performance - Excellent** âœ…\\n\\n**Overall Network Score:** {{Math.round($json.summary.overall_network_score)}}% ({{$json.summary.overall_network_status.toUpperCase()}})\\n\\n**Performance Summary:**\\nâ€¢ Total Monitoring Points: {{$json.summary.total_monitored_points}}\\nâ€¢ UXI Sensors: {{$json.summary.uxi_sensors}}\\nâ€¢ Network Segments: {{$json.summary.network_segments}}\\nâ€¢ WAN Connections: {{$json.summary.wan_connections}}\\n\\n**Performance Distribution:**\\nâ€¢ Excellent: {{$json.summary.performance_distribution.excellent}}\\nâ€¢ Good: {{$json.summary.performance_distribution.good}}\\nâ€¢ Acceptable: {{$json.summary.performance_distribution.acceptable}}\\n\\n**Status:** All network performance metrics are within acceptable ranges\\n\\n**Timestamp:** {{$json.timestamp}}",
        "otherOptions": {
          "mrkdwn": true,
          "unfurl_links": false,
          "unfurl_media": false
        }
      },
      "id": "d2e3f4a5-da6b-f5a6-eb7c-2d3e4f5a6b7c",
      "name": "Good Performance Status",
      "type": "n8n-nodes-base.slack",
      "typeVersion": 2,
      "position": [
        1340,
        500
      ]
    },
    {
      "parameters": {
        "url": "https://your-metrics-database.com/api/v1/performance-metrics",
        "method": "POST",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Authorization",
              "value": "Bearer your-metrics-api-key"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "timestamp",
              "value": "={{$json.timestamp}}"
            },
            {
              "name": "summary",
              "value": "={{JSON.stringify($json.summary)}}"
            },
            {
              "name": "uxi_performance",
              "value": "={{JSON.stringify($json.uxi_performance)}}"
            },
            {
              "name": "network_performance",
              "value": "={{JSON.stringify($json.network_performance)}}"
            },
            {
              "name": "wan_performance",
              "value": "={{JSON.stringify($json.wan_performance)}}"
            },
            {
              "name": "insights",
              "value": "={{JSON.stringify($json.insights)}}"
            },
            {
              "name": "trends",
              "value": "={{JSON.stringify($json.trends)}}"
            },
            {
              "name": "source",
              "value": "network_performance_monitoring"
            }
          ]
        },
        "options": {
          "timeout": 30000,
          "retry": {
            "maxTries": 3,
            "waitBetweenTries": 2000
          }
        }
      },
      "id": "e3f4a5b6-eb7c-a6b7-fc8d-3e4f5a6b7c8d",
      "name": "Store Performance Metrics",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1560,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Generate performance optimization recommendations\nconst summary = $json.summary;\nconst criticalPerformance = $json.critical_performance || [];\nconst poorPerformance = $json.poor_performance || [];\nconst insights = $json.insights || [];\nconst uxiPerformance = $json.uxi_performance || [];\nconst networkPerformance = $json.network_performance || [];\nconst wanPerformance = $json.wan_performance || [];\n\nconst optimizations = [];\n\n// Analyze latency issues\nconst highLatencyPoints = [...uxiPerformance, ...networkPerformance, ...wanPerformance]\n  .filter(p => p.metrics.latency && p.metrics.latency.status === 'critical');\n\nif (highLatencyPoints.length > 0) {\n  optimizations.push({\n    type: 'latency_optimization',\n    priority: 'high',\n    affected_points: highLatencyPoints.length,\n    description: `High latency detected at ${highLatencyPoints.length} network points`,\n    recommendations: [\n      'Implement QoS policies to prioritize critical traffic',\n      'Review routing tables and optimize network paths',\n      'Consider traffic shaping and bandwidth allocation',\n      'Investigate network congestion and bottlenecks'\n    ],\n    actions: [\n      {\n        action: 'optimize_qos',\n        description: 'Apply QoS optimization policies',\n        api_endpoint: '/api/v2/qos/optimize',\n        parameters: {\n          optimization_type: 'latency_focused',\n          affected_networks: highLatencyPoints.map(p => p.network_id || p.sensor_id || p.wan_id)\n        }\n      },\n      {\n        action: 'analyze_routing',\n        description: 'Analyze and optimize routing paths',\n        api_endpoint: '/api/v2/routing/analyze',\n        parameters: {\n          analysis_type: 'latency_optimization',\n          target_networks: highLatencyPoints.map(p => p.network_id || p.sensor_id || p.wan_id)\n        }\n      }\n    ]\n  });\n}\n\n// Analyze throughput issues\nconst lowThroughputPoints = [...uxiPerformance, ...networkPerformance, ...wanPerformance]\n  .filter(p => p.metrics.throughput && p.metrics.throughput.status === 'critical');\n\nif (lowThroughputPoints.length > 0) {\n  optimizations.push({\n    type: 'throughput_optimization',\n    priority: 'high',\n    affected_points: lowThroughputPoints.length,\n    description: `Low throughput detected at ${lowThroughputPoints.length} network points`,\n    recommendations: [\n      'Increase bandwidth allocation for affected networks',\n      'Implement traffic compression and optimization',\n      'Review and optimize network hardware utilization',\n      'Consider load balancing across multiple paths'\n    ],\n    actions: [\n      {\n        action: 'increase_bandwidth',\n        description: 'Increase bandwidth allocation',\n        api_endpoint: '/api/v2/bandwidth/allocate',\n        parameters: {\n          allocation_type: 'throughput_optimization',\n          affected_networks: lowThroughputPoints.map(p => p.network_id || p.sensor_id || p.wan_id),\n          increase_percentage: 25\n        }\n      },\n      {\n        action: 'enable_compression',\n        description: 'Enable traffic compression',\n        api_endpoint: '/api/v2/optimization/compression',\n        parameters: {\n          compression_type: 'adaptive',\n          target_networks: lowThroughputPoints.map(p => p.network_id || p.sensor_id || p.wan_id)\n        }\n      }\n    ]\n  });\n}\n\n// Analyze packet loss issues\nconst packetLossPoints = [...uxiPerformance, ...networkPerformance, ...wanPerformance]\n  .filter(p => p.metrics.packet_loss && p.metrics.packet_loss.status === 'critical');\n\nif (packetLossPoints.length > 0) {\n  optimizations.push({\n    type: 'packet_loss_mitigation',\n    priority: 'critical',\n    affected_points: packetLossPoints.length,\n    description: `Packet loss detected at ${packetLossPoints.length} network points`,\n    recommendations: [\n      'Investigate network hardware health and stability',\n      'Implement error correction and retry mechanisms',\n      'Review and optimize buffer sizes and queue management',\n      'Consider redundant path configuration'\n    ],\n    actions: [\n      {\n        action: 'hardware_health_check',\n        description: 'Perform comprehensive hardware health check',\n        api_endpoint: '/api/v2/hardware/health-check',\n        parameters: {\n          check_type: 'comprehensive',\n          affected_devices: packetLossPoints.map(p => p.network_id || p.sensor_id || p.wan_id)\n        }\n      },\n      {\n        action: 'configure_redundancy',\n        description: 'Configure redundant network paths',\n        api_endpoint: '/api/v2/redundancy/configure',\n        parameters: {\n          redundancy_type: 'active_backup',\n          target_networks: packetLossPoints.map(p => p.network_id || p.sensor_id || p.wan_id)\n        }\n      }\n    ]\n  });\n}\n\n// WAN-specific optimizations\nconst criticalWanPoints = wanPerformance.filter(w => w.overall_status === 'critical');\nif (criticalWanPoints.length > 0) {\n  optimizations.push({\n    type: 'wan_optimization',\n    priority: 'high',\n    affected_points: criticalWanPoints.length,\n    description: `Critical WAN performance issues at ${criticalWanPoints.length} WAN connections`,\n    recommendations: [\n      'Implement WAN optimization techniques',\n      'Configure adaptive traffic shaping',\n      'Enable WAN acceleration and caching',\n      'Review ISP SLA and consider alternative providers'\n    ],\n    actions: [\n      {\n        action: 'enable_wan_optimization',\n        description: 'Enable comprehensive WAN optimization',\n        api_endpoint: '/api/v1/wan/optimize',\n        parameters: {\n          optimization_profile: 'comprehensive',\n          wan_connections: criticalWanPoints.map(w => w.wan_id),\n          enable_compression: true,\n          enable_caching: true,\n          enable_acceleration: true\n        }\n      }\n    ]\n  });\n}\n\n// UXI-specific optimizations\nconst criticalUxiPoints = uxiPerformance.filter(u => u.overall_status === 'critical');\nif (criticalUxiPoints.length > 0) {\n  optimizations.push({\n    type: 'user_experience_optimization',\n    priority: 'high',\n    affected_points: criticalUxiPoints.length,\n    description: `Poor user experience at ${criticalUxiPoints.length} locations`,\n    recommendations: [\n      'Optimize wireless network configuration',\n      'Implement application-aware QoS',\n      'Review and optimize DNS resolution',\n      'Consider edge computing and local caching'\n    ],\n    actions: [\n      {\n        action: 'optimize_wireless',\n        description: 'Optimize wireless network configuration',\n        api_endpoint: '/api/v2/wireless/optimize',\n        parameters: {\n          optimization_type: 'user_experience',\n          affected_sensors: criticalUxiPoints.map(u => u.sensor_id)\n        }\n      },\n      {\n        action: 'implement_app_qos',\n        description: 'Implement application-aware QoS',\n        api_endpoint: '/api/v2/qos/application-aware',\n        parameters: {\n          profile: 'user_experience_focused',\n          target_locations: criticalUxiPoints.map(u => u.location)\n        }\n      }\n    ]\n  });\n}\n\n// Performance trend analysis and predictive optimizations\nconst predictiveOptimizations = [];\n\n// Check for gradual degradation patterns\nif (summary.overall_network_score < 80) {\n  predictiveOptimizations.push({\n    type: 'preventive_maintenance',\n    priority: 'medium',\n    description: 'Network performance trending downward - schedule preventive maintenance',\n    recommendation: 'Schedule comprehensive network maintenance during next maintenance window',\n    action: {\n      action: 'schedule_maintenance',\n      description: 'Schedule preventive network maintenance',\n      api_endpoint: '/api/v2/maintenance/schedule',\n      parameters: {\n        maintenance_type: 'preventive',\n        maintenance_window: 'next_available',\n        scope: 'network_optimization'\n      }\n    }\n  });\n}\n\n// Generate executive summary\nconst executiveSummary = {\n  overall_network_health: summary.overall_network_score,\n  total_optimization_opportunities: optimizations.length,\n  high_priority_optimizations: optimizations.filter(o => o.priority === 'high').length,\n  critical_priority_optimizations: optimizations.filter(o => o.priority === 'critical').length,\n  estimated_improvement: {\n    latency_reduction: '15-30%',\n    throughput_increase: '10-25%',\n    packet_loss_reduction: '50-80%',\n    user_satisfaction: '20-40%'\n  },\n  implementation_timeline: {\n    immediate: optimizations.filter(o => o.priority === 'critical').length,\n    short_term: optimizations.filter(o => o.priority === 'high').length,\n    medium_term: optimizations.filter(o => o.priority === 'medium').length\n  }\n};\n\nreturn [{\n  json: {\n    timestamp: new Date().toISOString(),\n    optimizations: optimizations,\n    predictive_optimizations: predictiveOptimizations,\n    executive_summary: executiveSummary,\n    total_recommendations: optimizations.length + predictiveOptimizations.length,\n    auto_implement: false, // Set to true for automatic implementation\n    requires_approval: true\n  }\n}];"
      },
      "id": "f4a5b6c7-fc8d-b7c8-ad9e-4f5a6b7c8d9e",
      "name": "Generate Performance Optimizations",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1560,
        500
      ]
    }
  ],
  "connections": {
    "Every 1 Minute": {
      "main": [
        [
          {
            "node": "Initialize Performance Monitoring",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Initialize Performance Monitoring": {
      "main": [
        [
          {
            "node": "Get UXI Sensors",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get UXI Test Results",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Network Metrics",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get WAN Performance",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get UXI Sensors": {
      "main": [
        [
          {
            "node": "Analyze Performance Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get UXI Test Results": {
      "main": [
        [
          {
            "node": "Analyze Performance Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Network Metrics": {
      "main": [
        [
          {
            "node": "Analyze Performance Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get WAN Performance": {
      "main": [
        [
          {
            "node": "Analyze Performance Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Analyze Performance Data": {
      "main": [
        [
          {
            "node": "Check Critical Performance",
            "type": "main",
            "index": 0
          },
          {
            "node": "Check Poor Performance",
            "type": "main",
            "index": 0
          },
          {
            "node": "Store Performance Metrics",
            "type": "main",
            "index": 0
          },
          {
            "node": "Generate Performance Optimizations",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Critical Performance": {
      "main": [
        [
          {
            "node": "Critical Performance Alert",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Check Poor Performance",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Poor Performance": {
      "main": [
        [
          {
            "node": "Poor Performance Alert",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Good Performance Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "versionId": "1.0.0",
  "meta": {
    "templateCreatedBy": "Claude Code",
    "description": "Comprehensive network performance monitoring workflow that tracks latency, throughput, packet loss, jitter, and user experience metrics across UXI sensors, network infrastructure, and WAN connections. Includes intelligent performance scoring, optimization recommendations, and predictive analytics.",
    "tags": ["monitoring", "performance", "uxi", "wan", "network", "latency", "throughput", "optimization", "analytics"]
  }
}