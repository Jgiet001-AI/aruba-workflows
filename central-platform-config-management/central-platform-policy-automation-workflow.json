{
  "name": "Central Platform Policy and Rule Automation",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "central-policy-automation",
        "responseMode": "responseNode",
        "options": {}
      },
      "name": "Policy Automation Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [200, 300],
      "webhookId": "policy-automation-webhook"
    },
    {
      "parameters": {
        "functionCode": "// Central Platform Policy and Rule Automation\n// Parse and validate incoming request\n\nconst operation = items[0].json.operation;\nconst policyData = items[0].json.policy_data || {};\nconst options = items[0].json.options || {};\n\n// Validate required fields\nif (!operation) {\n  throw new Error('Operation is required');\n}\n\n// Supported operations\nconst supportedOps = [\n  'create_policy',\n  'update_policy',\n  'delete_policy',\n  'list_policies',\n  'apply_policy',\n  'validate_policy',\n  'policy_compliance_check',\n  'create_rule',\n  'update_rule',\n  'delete_rule',\n  'bulk_policy_apply',\n  'policy_rollback'\n];\n\nif (!supportedOps.includes(operation)) {\n  throw new Error(`Unsupported operation: ${operation}. Supported: ${supportedOps.join(', ')}`);\n}\n\n// Operation-specific validation\nif (['create_policy', 'update_policy', 'apply_policy'].includes(operation)) {\n  if (!policyData.policy_name) {\n    throw new Error('Policy name is required');\n  }\n  if (!policyData.policy_type) {\n    throw new Error('Policy type is required');\n  }\n}\n\nif (operation === 'update_policy' && !policyData.policy_id) {\n  throw new Error('Policy ID is required for update operations');\n}\n\nif (operation === 'apply_policy' && !policyData.target_devices) {\n  throw new Error('Target devices are required for policy application');\n}\n\n// Add timestamp and execution ID\nconst executionData = {\n  operation,\n  policy_data: policyData,\n  options,\n  timestamp: new Date().toISOString(),\n  execution_id: `policy-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n};\n\nconsole.log(`Policy Automation: ${operation} - ${executionData.execution_id}`);\n\nreturn [{ json: executionData }];"
      },
      "name": "Parse Policy Request",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [400, 300]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.operation}}",
              "value2": "create_policy"
            }
          ]
        }
      },
      "name": "Check Create Policy",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [600, 300]
    },
    {
      "parameters": {
        "functionCode": "// Create Policy Operation\nconst data = items[0].json;\nconst policyData = data.policy_data;\n\n// Policy creation payload\nconst createPayload = {\n  policy_name: policyData.policy_name,\n  policy_type: policyData.policy_type,\n  description: policyData.description || `Policy created via automation - ${data.timestamp}`,\n  version: policyData.version || '1.0.0',\n  enabled: policyData.enabled !== false,\n  priority: policyData.priority || 100,\n  metadata: {\n    created_by: 'Central Platform Automation',\n    created_at: data.timestamp,\n    execution_id: data.execution_id,\n    source: 'n8n-workflow'\n  }\n};\n\n// Policy type-specific configuration\nswitch (policyData.policy_type) {\n  case 'network_access':\n    createPayload.access_rules = policyData.access_rules || [];\n    createPayload.authentication_required = policyData.authentication_required !== false;\n    createPayload.vlan_assignment = policyData.vlan_assignment || {};\n    createPayload.bandwidth_limits = policyData.bandwidth_limits || {};\n    break;\n  case 'security':\n    createPayload.security_rules = policyData.security_rules || [];\n    createPayload.threat_detection = policyData.threat_detection || 'enabled';\n    createPayload.intrusion_prevention = policyData.intrusion_prevention || 'enabled';\n    createPayload.encryption_requirements = policyData.encryption_requirements || {};\n    break;\n  case 'qos':\n    createPayload.qos_rules = policyData.qos_rules || [];\n    createPayload.traffic_classification = policyData.traffic_classification || [];\n    createPayload.bandwidth_allocation = policyData.bandwidth_allocation || {};\n    createPayload.priority_queues = policyData.priority_queues || [];\n    break;\n  case 'compliance':\n    createPayload.compliance_rules = policyData.compliance_rules || [];\n    createPayload.audit_requirements = policyData.audit_requirements || {};\n    createPayload.regulatory_standards = policyData.regulatory_standards || [];\n    createPayload.reporting_schedule = policyData.reporting_schedule || 'daily';\n    break;\n  case 'application':\n    createPayload.application_rules = policyData.application_rules || [];\n    createPayload.allowed_applications = policyData.allowed_applications || [];\n    createPayload.blocked_applications = policyData.blocked_applications || [];\n    createPayload.bandwidth_per_app = policyData.bandwidth_per_app || {};\n    break;\n}\n\n// Add conditions\nif (policyData.conditions) {\n  createPayload.conditions = {\n    time_based: policyData.conditions.time_based || {},\n    location_based: policyData.conditions.location_based || {},\n    device_based: policyData.conditions.device_based || {},\n    user_based: policyData.conditions.user_based || {}\n  };\n}\n\n// Add enforcement settings\ncreatePayload.enforcement = {\n  mode: policyData.enforcement_mode || 'enforce',\n  logging: policyData.logging_enabled !== false,\n  alert_on_violation: policyData.alert_on_violation !== false,\n  auto_remediation: policyData.auto_remediation || false\n};\n\n// Return API request data\nreturn [{ \n  json: {\n    ...data,\n    api_payload: createPayload,\n    api_endpoint: '/api/v2/policies',\n    api_method: 'POST'\n  }\n}];"
      },
      "name": "Create Policy",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [800, 200]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.operation}}",
              "value2": "apply_policy"
            }
          ]
        }
      },
      "name": "Check Apply Policy",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [800, 300]
    },
    {
      "parameters": {
        "functionCode": "// Apply Policy Operation\nconst data = items[0].json;\nconst policyData = data.policy_data;\n\n// Policy application payload\nconst applyPayload = {\n  policy_id: policyData.policy_id || policyData.policy_name,\n  target_devices: policyData.target_devices,\n  target_groups: policyData.target_groups || [],\n  target_users: policyData.target_users || [],\n  application_settings: {\n    mode: policyData.application_mode || 'immediate',\n    schedule: policyData.application_schedule || null,\n    rollback_on_failure: policyData.rollback_on_failure !== false,\n    pre_validation: policyData.pre_validation !== false,\n    post_validation: policyData.post_validation !== false\n  },\n  deployment_options: {\n    staged: policyData.staged_deployment || false,\n    batch_size: policyData.batch_size || 50,\n    delay_between_batches: policyData.delay_between_batches || 30,\n    priority: policyData.deployment_priority || 'normal'\n  },\n  override_settings: policyData.override_settings || {},\n  conflict_resolution: policyData.conflict_resolution || 'merge',\n  notification_settings: {\n    notify_on_success: true,\n    notify_on_failure: true,\n    notify_users: policyData.notify_users || []\n  }\n};\n\n// Add application metadata\napplyPayload.metadata = {\n  applied_by: 'Central Platform Automation',\n  applied_at: data.timestamp,\n  execution_id: data.execution_id,\n  reason: policyData.reason || 'Automated policy application'\n};\n\n// Validate targets\nif ((!applyPayload.target_devices || applyPayload.target_devices.length === 0) &&\n    (!applyPayload.target_groups || applyPayload.target_groups.length === 0) &&\n    (!applyPayload.target_users || applyPayload.target_users.length === 0)) {\n  throw new Error('At least one target (devices, groups, or users) must be specified');\n}\n\nreturn [{ \n  json: {\n    ...data,\n    api_payload: applyPayload,\n    api_endpoint: '/api/v2/policies/apply',\n    api_method: 'POST',\n    target_count: (applyPayload.target_devices?.length || 0) + \n                  (applyPayload.target_groups?.length || 0) + \n                  (applyPayload.target_users?.length || 0)\n  }\n}];"
      },
      "name": "Apply Policy",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1000, 300]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.operation}}",
              "value2": "validate_policy"
            }
          ]
        }
      },
      "name": "Check Validate Policy",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [800, 400]
    },
    {
      "parameters": {
        "functionCode": "// Validate Policy Operation\nconst data = items[0].json;\nconst policyData = data.policy_data;\n\n// Validation payload\nconst validatePayload = {\n  policy_id: policyData.policy_id,\n  validation_level: policyData.validation_level || 'full',\n  target_devices: policyData.target_devices || [],\n  simulation_mode: policyData.simulation_mode !== false,\n  checks: {\n    syntax_check: true,\n    conflict_check: true,\n    dependency_check: true,\n    performance_impact: true,\n    compliance_check: policyData.compliance_check !== false\n  },\n  validation_options: {\n    check_prerequisites: true,\n    validate_targets: true,\n    estimate_impact: true,\n    generate_report: true\n  }\n};\n\nreturn [{ \n  json: {\n    ...data,\n    api_payload: validatePayload,\n    api_endpoint: `/api/v2/policies/${policyData.policy_id}/validate`,\n    api_method: 'POST'\n  }\n}];"
      },
      "name": "Validate Policy",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1000, 400]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.operation}}",
              "value2": "policy_compliance_check"
            }
          ]
        }
      },
      "name": "Check Compliance",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [800, 500]
    },
    {
      "parameters": {
        "functionCode": "// Policy Compliance Check Operation\nconst data = items[0].json;\nconst policyData = data.policy_data;\n\n// Compliance check payload\nconst compliancePayload = {\n  policy_ids: policyData.policy_ids || [],\n  target_devices: policyData.target_devices || [],\n  compliance_standards: policyData.compliance_standards || [],\n  check_options: {\n    deep_scan: policyData.deep_scan !== false,\n    include_inactive: policyData.include_inactive || false,\n    check_exceptions: policyData.check_exceptions !== false,\n    validate_remediation: policyData.validate_remediation || true\n  },\n  reporting_options: {\n    detailed_report: true,\n    executive_summary: true,\n    remediation_steps: true,\n    compliance_score: true\n  },\n  time_range: {\n    start: policyData.start_time || new Date(Date.now() - 24*60*60*1000).toISOString(),\n    end: policyData.end_time || new Date().toISOString()\n  }\n};\n\nreturn [{ \n  json: {\n    ...data,\n    api_payload: compliancePayload,\n    api_endpoint: '/api/v2/policies/compliance-check',\n    api_method: 'POST'\n  }\n}];"
      },
      "name": "Compliance Check",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1000, 500]
    },
    {
      "parameters": {
        "functionCode": "// Handle other policy operations\nconst data = items[0].json;\nconst operation = data.operation;\nconst policyData = data.policy_data;\n\nlet apiEndpoint = '';\nlet apiMethod = 'GET';\nlet apiPayload = null;\n\nswitch (operation) {\n  case 'update_policy':\n    apiEndpoint = `/api/v2/policies/${policyData.policy_id}`;\n    apiMethod = 'PUT';\n    apiPayload = {\n      policy_name: policyData.policy_name,\n      description: policyData.description,\n      version: policyData.version,\n      enabled: policyData.enabled,\n      priority: policyData.priority,\n      rules: policyData.rules,\n      conditions: policyData.conditions,\n      metadata: {\n        updated_by: 'Central Platform Automation',\n        updated_at: data.timestamp,\n        execution_id: data.execution_id\n      }\n    };\n    // Remove undefined fields\n    Object.keys(apiPayload).forEach(key => {\n      if (apiPayload[key] === undefined) delete apiPayload[key];\n    });\n    break;\n  case 'delete_policy':\n    apiEndpoint = `/api/v2/policies/${policyData.policy_id}`;\n    apiMethod = 'DELETE';\n    break;\n  case 'list_policies':\n    const queryParams = {\n      limit: data.options.limit || 50,\n      offset: data.options.offset || 0,\n      policy_type: data.options.policy_type,\n      enabled: data.options.enabled,\n      sort_by: data.options.sort_by || 'created_at',\n      sort_order: data.options.sort_order || 'desc'\n    };\n    const queryString = Object.keys(queryParams)\n      .filter(key => queryParams[key] !== undefined)\n      .map(key => `${key}=${encodeURIComponent(queryParams[key])}`)\n      .join('&');\n    apiEndpoint = `/api/v2/policies?${queryString}`;\n    break;\n  case 'create_rule':\n    apiEndpoint = `/api/v2/policies/${policyData.policy_id}/rules`;\n    apiMethod = 'POST';\n    apiPayload = {\n      rule_name: policyData.rule_name,\n      rule_type: policyData.rule_type,\n      conditions: policyData.conditions,\n      actions: policyData.actions,\n      priority: policyData.priority || 100,\n      enabled: policyData.enabled !== false\n    };\n    break;\n  case 'update_rule':\n    apiEndpoint = `/api/v2/policies/${policyData.policy_id}/rules/${policyData.rule_id}`;\n    apiMethod = 'PUT';\n    apiPayload = {\n      rule_name: policyData.rule_name,\n      conditions: policyData.conditions,\n      actions: policyData.actions,\n      priority: policyData.priority,\n      enabled: policyData.enabled\n    };\n    break;\n  case 'delete_rule':\n    apiEndpoint = `/api/v2/policies/${policyData.policy_id}/rules/${policyData.rule_id}`;\n    apiMethod = 'DELETE';\n    break;\n  case 'bulk_policy_apply':\n    apiEndpoint = '/api/v2/policies/bulk-apply';\n    apiMethod = 'POST';\n    apiPayload = {\n      policy_applications: policyData.policy_applications || [],\n      global_settings: policyData.global_settings || {},\n      execution_mode: policyData.execution_mode || 'parallel'\n    };\n    break;\n  case 'policy_rollback':\n    apiEndpoint = `/api/v2/policies/${policyData.policy_id}/rollback`;\n    apiMethod = 'POST';\n    apiPayload = {\n      rollback_to: policyData.rollback_version || 'previous',\n      target_devices: policyData.target_devices || [],\n      reason: policyData.reason || 'Manual rollback request'\n    };\n    break;\n  default:\n    throw new Error(`Unsupported operation: ${operation}`);\n}\n\nreturn [{ \n  json: {\n    ...data,\n    api_payload: apiPayload,\n    api_endpoint: apiEndpoint,\n    api_method: apiMethod\n  }\n}];"
      },
      "name": "Handle Other Operations",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1000, 600]
    },
    {
      "parameters": {
        "url": "={{$json.api_endpoint}}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "arubaApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Authorization",
              "value": "Bearer {{$credentials.arubaApi.accessToken}}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "data",
              "value": "={{JSON.stringify($json.api_payload)}}"
            }
          ]
        },
        "options": {
          "timeout": 45000,
          "retry": {
            "maxTries": 3,
            "waitBetweenTries": 3000
          }
        }
      },
      "name": "Execute API Request",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [1200, 400]
    },
    {
      "parameters": {
        "functionCode": "// Process API Success Response\nconst data = items[0].json;\nconst originalRequest = data.originalRequest || {};\n\n// Extract response data\nconst responseData = data.response || data;\nconst statusCode = data.statusCode || 200;\nconst operation = originalRequest.operation;\n\n// Success response processing\nlet processedResponse = {\n  success: true,\n  operation: operation,\n  timestamp: new Date().toISOString(),\n  execution_id: originalRequest.execution_id,\n  status_code: statusCode,\n  data: responseData\n};\n\n// Operation-specific response processing\nswitch (operation) {\n  case 'create_policy':\n    processedResponse.policy_id = responseData.policy_id || responseData.id;\n    processedResponse.policy_name = responseData.policy_name;\n    processedResponse.policy_type = responseData.policy_type;\n    processedResponse.message = `Policy '${responseData.policy_name}' created successfully`;\n    break;\n  case 'update_policy':\n    processedResponse.policy_id = responseData.policy_id || responseData.id;\n    processedResponse.version = responseData.version;\n    processedResponse.message = `Policy updated to version ${responseData.version}`;\n    break;\n  case 'apply_policy':\n    processedResponse.application_id = responseData.application_id;\n    processedResponse.affected_devices = responseData.affected_devices || [];\n    processedResponse.status = responseData.status;\n    processedResponse.message = `Policy applied to ${responseData.affected_devices?.length || 0} targets`;\n    break;\n  case 'validate_policy':\n    processedResponse.validation_result = responseData.validation_result;\n    processedResponse.validation_score = responseData.validation_score;\n    processedResponse.issues = responseData.issues || [];\n    processedResponse.warnings = responseData.warnings || [];\n    processedResponse.message = `Policy validation completed - Score: ${responseData.validation_score}/100`;\n    break;\n  case 'policy_compliance_check':\n    processedResponse.compliance_score = responseData.compliance_score;\n    processedResponse.compliant_devices = responseData.compliant_devices || [];\n    processedResponse.non_compliant_devices = responseData.non_compliant_devices || [];\n    processedResponse.violations = responseData.violations || [];\n    processedResponse.message = `Compliance check completed - Score: ${responseData.compliance_score}%`;\n    break;\n  case 'list_policies':\n    processedResponse.total_count = responseData.total_count || responseData.length;\n    processedResponse.policies = responseData.policies || responseData;\n    processedResponse.message = `Retrieved ${processedResponse.total_count} policies`;\n    break;\n  case 'delete_policy':\n    processedResponse.message = 'Policy deleted successfully';\n    break;\n  case 'create_rule':\n    processedResponse.rule_id = responseData.rule_id;\n    processedResponse.rule_name = responseData.rule_name;\n    processedResponse.message = `Rule '${responseData.rule_name}' created successfully`;\n    break;\n  case 'bulk_policy_apply':\n    processedResponse.batch_id = responseData.batch_id;\n    processedResponse.total_applications = responseData.total_applications;\n    processedResponse.successful = responseData.successful || 0;\n    processedResponse.failed = responseData.failed || 0;\n    processedResponse.message = `Bulk policy application initiated - ${responseData.total_applications} policies`;\n    break;\n  case 'policy_rollback':\n    processedResponse.rollback_id = responseData.rollback_id;\n    processedResponse.rollback_status = responseData.status;\n    processedResponse.affected_devices = responseData.affected_devices || [];\n    processedResponse.message = `Policy rollback initiated for ${responseData.affected_devices?.length || 0} devices`;\n    break;\n}\n\n// Add performance metrics\nprocessedResponse.metrics = {\n  response_time: data.response_time || 'N/A',\n  api_calls: 1,\n  success_rate: '100%'\n};\n\nconsole.log(`Policy Automation Success: ${operation} - ${processedResponse.execution_id}`);\n\nreturn [{ json: processedResponse }];"
      },
      "name": "Process Success Response",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1400, 400]
    },
    {
      "parameters": {
        "functionCode": "// Process Error Response\nconst error = items[0].json.error || items[0].json;\nconst originalRequest = items[0].json.originalRequest || {};\n\n// Extract error details\nconst errorResponse = {\n  success: false,\n  operation: originalRequest.operation,\n  timestamp: new Date().toISOString(),\n  execution_id: originalRequest.execution_id,\n  error: {\n    code: error.code || error.statusCode || 'UNKNOWN_ERROR',\n    message: error.message || 'Unknown error occurred',\n    details: error.details || error.response || {},\n    stack: error.stack\n  }\n};\n\n// Error categorization\nconst errorCode = errorResponse.error.code;\nif (errorCode >= 400 && errorCode < 500) {\n  errorResponse.error.category = 'CLIENT_ERROR';\n  errorResponse.error.retry_recommended = false;\n} else if (errorCode >= 500) {\n  errorResponse.error.category = 'SERVER_ERROR';\n  errorResponse.error.retry_recommended = true;\n} else {\n  errorResponse.error.category = 'UNKNOWN_ERROR';\n  errorResponse.error.retry_recommended = false;\n}\n\n// Operation-specific error handling\nswitch (originalRequest.operation) {\n  case 'create_policy':\n    if (errorCode === 409) {\n      errorResponse.error.message = 'Policy with this name already exists';\n    } else if (errorCode === 400) {\n      errorResponse.error.message = 'Invalid policy configuration';\n    }\n    break;\n  case 'apply_policy':\n    if (errorCode === 404) {\n      errorResponse.error.message = 'Policy not found';\n    } else if (errorCode === 422) {\n      errorResponse.error.message = 'Policy validation failed for target devices';\n    }\n    break;\n  case 'validate_policy':\n    if (errorCode === 400) {\n      errorResponse.error.message = 'Policy syntax validation failed';\n    }\n    break;\n  case 'policy_compliance_check':\n    if (errorCode === 503) {\n      errorResponse.error.message = 'Compliance service temporarily unavailable';\n    }\n    break;\n}\n\nconsole.error(`Policy Automation Error: ${originalRequest.operation} - ${errorResponse.execution_id}`, errorResponse.error);\n\nreturn [{ json: errorResponse }];"
      },
      "name": "Process Error Response",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1400, 600]
    },
    {
      "parameters": {
        "channel": "={{$json.notification_settings?.slack?.channel || '#central-platform-automation'}}",
        "text": "📋 **Central Platform Policy Automation**\\n\\n**Operation**: {{$json.operation}}\\n**Status**: {{$json.success ? '✅ Success' : '❌ Failed'}}\\n**Policy**: {{$json.policy_name || $json.policy_id}}\\n**Execution ID**: {{$json.execution_id}}\\n**Message**: {{$json.message || $json.error?.message}}\\n**Timestamp**: {{$json.timestamp}}\\n\\n{{$json.success ? '**Details**: ' + ($json.compliance_score ? 'Compliance Score: ' + $json.compliance_score + '%' : $json.affected_devices ? 'Affected Devices: ' + $json.affected_devices.length : '') : '**Error Code**: ' + $json.error?.code}}",
        "username": "Policy Automation Bot",
        "iconEmoji": ":clipboard:"
      },
      "name": "Send Slack Notification",
      "type": "n8n-nodes-base.slack",
      "typeVersion": 1,
      "position": [1600, 400]
    },
    {
      "parameters": {
        "functionCode": "// Final Response Formatter\nconst data = items[0].json;\n\n// Format final response\nconst finalResponse = {\n  success: data.success,\n  operation: data.operation,\n  execution_id: data.execution_id,\n  timestamp: data.timestamp,\n  message: data.message\n};\n\n// Add operation-specific data\nif (data.success) {\n  finalResponse.data = data.data;\n  finalResponse.metrics = data.metrics;\n  \n  // Add specific fields based on operation\n  if (data.policy_id) finalResponse.policy_id = data.policy_id;\n  if (data.policy_name) finalResponse.policy_name = data.policy_name;\n  if (data.application_id) finalResponse.application_id = data.application_id;\n  if (data.validation_result) finalResponse.validation_result = data.validation_result;\n  if (data.compliance_score) finalResponse.compliance_score = data.compliance_score;\n  if (data.total_count) finalResponse.total_count = data.total_count;\n} else {\n  finalResponse.error = data.error;\n  finalResponse.retry_recommended = data.error?.retry_recommended;\n}\n\n// Add execution summary\nfinalResponse.execution_summary = {\n  workflow: 'Central Platform Policy and Rule Automation',\n  version: '1.0.0',\n  executed_at: data.timestamp,\n  duration: 'N/A' // Could be calculated if needed\n};\n\nreturn [{ json: finalResponse }];"
      },
      "name": "Format Final Response",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1800, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{JSON.stringify($json, null, 2)}}"
      },
      "name": "Return Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2000, 400]
    }
  ],
  "connections": {
    "Policy Automation Webhook": {
      "main": [
        [
          {
            "node": "Parse Policy Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Policy Request": {
      "main": [
        [
          {
            "node": "Check Create Policy",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Create Policy": {
      "main": [
        [
          {
            "node": "Create Policy",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Check Apply Policy",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Policy": {
      "main": [
        [
          {
            "node": "Execute API Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Apply Policy": {
      "main": [
        [
          {
            "node": "Apply Policy",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Check Validate Policy",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apply Policy": {
      "main": [
        [
          {
            "node": "Execute API Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Validate Policy": {
      "main": [
        [
          {
            "node": "Validate Policy",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Check Compliance",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Policy": {
      "main": [
        [
          {
            "node": "Execute API Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Compliance": {
      "main": [
        [
          {
            "node": "Compliance Check",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Handle Other Operations",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Compliance Check": {
      "main": [
        [
          {
            "node": "Execute API Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle Other Operations": {
      "main": [
        [
          {
            "node": "Execute API Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute API Request": {
      "main": [
        [
          {
            "node": "Process Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ],
      "error": [
        [
          {
            "node": "Process Error Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Success Response": {
      "main": [
        [
          {
            "node": "Send Slack Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Error Response": {
      "main": [
        [
          {
            "node": "Send Slack Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Slack Notification": {
      "main": [
        [
          {
            "node": "Format Final Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Final Response": {
      "main": [
        [
          {
            "node": "Return Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  }
}